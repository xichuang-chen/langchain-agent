# Feature
为chat agent 提供short memory 功能

# 示例
### Old world

```
用户: 我喜欢咖啡
Agent: 咖啡是一种受欢迎的饮品，许多人喜欢它的香气和提神效果。你喜欢哪种类型的咖啡呢？比如浓缩咖啡、拿铁、卡布奇诺，还是其他的？
用户：你还记得我喜欢什么吗
Agent: 我无法记住你喜欢什么，因为我没有个人记忆。
```
### New world
```
用户: 我喜欢咖啡
Agent: 咖啡是一种受欢迎的饮品，许多人喜欢它的香气和提神效果。你喜欢哪种类型的咖啡呢？比如浓缩咖啡、拿铁、卡布奇诺，还是其他的？
用户: 我喜欢的动物是小狗
Agent: 小狗真是可爱又忠诚的动物！它们通常活泼好动，喜欢与人互动。你有没有养小狗，或者有没有特别喜欢的犬种呢?
用户: 金毛
Agent: 金毛寻回犬（Golden Retriever）是一种非常受欢迎的犬种，以其友好、聪明和温顺的性格而闻名。它们非常适合家庭，通常与孩子和其他宠物相处得很好。你喜欢金毛的哪些特质呢？或者有没有养过金毛？
用户: 你还记得我喜欢的是什么吗
Agent: 当然记得！你喜欢咖啡和小狗，特别是金毛寻回犬。有什么想分享的或者想讨论的关于它们的事情吗？
```

# 遇到的问题

1. 当我问的问题 agent 找不到合适的工具时，会陷入循环

```
例如:
用户: 我喜欢咖啡  
Agent: Agent stopped due to max iterations.
```

### 根因：  
从终端日志看，Agent 在处理“我喜欢咖啡”时选择了 None 作为 action，随后因达到最大迭代次数而停止。
这通常是因为 Agent 未正确处理不需要工具调用的对话。

**ReactAgent 的工作方式**  
ReactAgent 使用 ReAct 框架：每一步会预测一个 Action（调用工具）或者 Final Answer, 如果 LLM 没有明确输出 Final Answer，或者输出不符合 ReAct 格式，Agent 会尝试继续迭代


**解决办法：**  
方案1:  让 Agent 在 tools 中加一个 默认回答工具  

```ts
new DynamicTool({
  name: "no_tool_needed",
  description: "普通对话或不需要工具的回答",
  func: async (input: string) => `Final Answer: ${input}`,
})
```
 
 这样，Agent 在普通问题时会调用 no_tool_needed 返回答案 → 避免无限迭代


 结果: 不可行！

 从日志来看，Agent 在处理“我喜欢咖啡”这类不需要调用工具的普通陈述时陷入了循环，不断选择 no_tool_needed，然后输出 "Final Answer: None"

 核心原因是：  
 - Agent 的 no_tool_needed 动作被视作一个工具调用。调用后返回 "Final Answer: None"，而 Agent 并没有真正把它当作最终答案处理。
 - 于是 Agent 认为问题还没解决，继续重复调用 no_tool_needed，导致无限循环直到达到最大迭代次数。
 - 目前逻辑是：所有问题都走 Thought → Action → Observation → 下一步的循环，而 no_tool_needed 的 Observation 没有触发“终止并返回最终答案”的信号。


所以，可能需要 no_tool_needed 返回一个标记，告诉 Agent 这是最终答案  

```
Observation: Final Answer: 我很高兴你喜欢咖啡！
```

 ---

 方案2: 强制 LLM 在无工具调用时输出 Final Answer

 ```
 如果问题不需要调用任何工具，请直接给出答案，并标记 Final Answer。
 ```

 使用自定义的prompt

---

 方案3: 设置agent迭代次数  
 agent的原理是，当没拿到合适的tool时，会不断迭代获取  
 本项目已设置

---

 方案4: 把调用工具改成 OpenAI 原生 tool-calling 的 agent（允许“选择不调用工具，直接给 Final”）  
 - ReAct 模型对“是否需要工具”的判断不是百分百准确。普通问题可能触发 Action: None 循环，导致模型反复尝试调用工具。
 - createToolCallingAgent 原生支持 “不需要工具时直接返回最终回答”，根本上解决循环问题。